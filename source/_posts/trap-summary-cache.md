title: 缓存中遇到的坑
date: 2017-08-15 09:06:21
tags:
---


在很多业务中，我们通常会用缓存来减少数据库的直接访问，来减轻负载提高性能。下面列举下，自己在使用缓存过程中遇到的坑。

坑1 我们之前遇到过一个比较坑的例子是，有一次活动有一个跳转页，运营配置错了id，这个id是数据库中不存在的。用户请求就会击穿缓存，直接请求DB。

坑2 有一个推送落地页，当用户点击推送时会跳到我们指定id的帖子页面。
我们在推送前已提前对此页面设置了缓存，并且设置了过期时间T。不过推送方除了问题，导致比我们预计的时间晚了很多，此时过期T已经超时，之前的缓存也被干掉了。这时候，用户集体收到了推送，瞬间大量用户访问某个固定页面。


## 恶意构造不会命中缓存的请求

在某些耗时较大访问频率较高的请求，我们加了缓存。比如数据库中有100个id，用户可能请求任意id获取数据，我们就会根据这些id加上一些前缀当成缓存key(比如prefix_id1)。这样做的问题是，只考虑了正常的请求。如果用户恶意构造数据库中压根不存在的id来请求，则每次均不会命中我们的缓存会直接打到DB中。


解决办法是，不仅要对正常的请求进行缓存，恶意的请求也要进行缓存。


## 缓存集体失效
这种情况也遇到过，依赖于大部分请求命中缓存不走DB。如果此时缓存集体失效(比如缓存崩了，过期了)的话，怎么办？势必所有请求都会打到DB，DB瞬间负载过高。

这里也提一个自己的解决办法，对于这种本应该大部分请求缓存少量不命中才查DB的请求，做一种加锁处理。
伪代码如下, 这里使用redis setnx 命令加锁



```
cache_value = redis.get(cache_key)
if not cache_value: # 缓存失效
	ok = redis.setnx(lock_key, lock_value)
	if ok:
		从数据库中获取数据，刷新cache_key
		redis.del(lock_key) # 释放锁
	else:
		# 获取不到锁，此时别人正在试图刷新缓存
		sleep(sometime)
		尝试重新获取cache_value

```

**一个问题**

其实细心的读者会发现这样有一个问题，那就是如果我setnx 成功了，加上了锁，恰好这个请求挂掉了。那么之后其余的并发请求试图更新缓存时都将被这把锁拦住。因此必须得**给这把锁加一个过期时间**。

redis 2.6.12 后 set 命令可以通过设置 nx 参数来支持setnx命令，同时本身又可以设置过期时间。
``r.set('my-key', 'my-value', nx=True, ex=10) ``

当然除了这个之外对于推送来讲还有别的改进意见了，就是对于非即时类消息不要集体推，要匀速推。比如在时间T内匀速推给所有用户。时间T取决于你推送落地页的抗压能力。