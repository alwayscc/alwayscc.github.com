title: 公司微服务发展的几个阶段
date: 2017-08-10 20:58:08
tags:
---

以下是个人两年创业期间公司微服务发展的一些看法

# 阶段一
表示层：显示数据和接收用户输入的数据，为用户提供交互式操作界面(也可以理解为客户端层)

业务逻辑层：根据用户输入信息，进行逻辑计算或者业务处理

数据层：在用户同应用程序交互的过程中，会产生数据。这类数据需要通过某种机制被有效的保存，并在将来能够被重复使用，或者提供给其他系统。

最早阶段一个django服务，所有层强耦合在一个django工程中。
此时适合业务相对简单的创业初期。

缺点：高度耦合。每一层如果有变化将影响整个工程
业务逻辑层发生变化
对于django 的MTV模式来讲，View层承担了部分表示层和全部业务逻辑层的功能。

假设现在有两个view，第一个view(记为V1)展示符合要求的买家，第二view(记为V2)展示符合要求的商品。
现在有了新需求需要一个新的view记为(V3)同时展示买家和商品。这样V3中必然有很多与V1和V2相同的逻辑代码。造成了不必要的冗余，之后如果买家逻辑有变，你就不得不同时变更V1和V3，不好维护。


# 阶段二
单独抽离出表示层，将与用户(客户端)直接交互的部分单独做成一个项目(内部称为backend)。

这样就可以解决阶段一出现的问题，可以在业务逻辑层将展示买家和展示商品单独作为服务接口，供表示层来调用。表示层可以根据自己需要随意拼装组合业务逻辑层的服务接口，来实现用户功能。

还有的好处可以实现高度的定制化，同样的客户端那边需要两个对外接口，均为需要展示商品。一个接口访问频率高，但并不要求实时。另一个接口访问频率不高，但要求数据是实时的。业务逻辑层保持不变，均为提供商品信息，可以在表示层对高频不实时接口做缓存。

虽然分离了表示层出去，但是全部的业务逻辑代码均在一个项目中。这种适合公司初具规模，业务线较少，开发成员没有明确业务线分组的情况。

缺点：

1. 随着公司发展业务线增多，开发人员按照业务线分组，不同项目组开发周期不同，但均要公用一个项目，就会造成小周期的组势必要等待大周期组。造成交付周期增长。

2. 项目代码不断壮大，维护的成本也慢慢增加。
3. 受限于整个庞大公用项目，不同业务线无法根据自身业务进行相应技术选型
4. 可伸缩性差，庞大服务中，不同业务可能需要的资源也不同，有的业务可能耗内存多，有的业务可能耗CPU多。当需要进行水平扩展时，运行应用的服务器不得不同时满足所有的资源要求，既需要大内存又需要高CPU，话费过高，也造成一定资源浪费。

公司当时采用了敏捷开发，两周一迭代。导致很多需要大周期才可做完的任务不得不被打散

# 阶段三 
阶段二面临的主要问题基本都是不同业务耦合性太强导致，阶段三做的就是按照业务来进行微服务的拆分。
将一个整体的复杂大项目拆分成N个独立的微服务。每个微服务各自提供不同的功能。不同微服务之间是松耦合，每个微服务仅关注于完成一件任务。不同项目组之间开发可根据自己需求定制，无需关心其余项目组的周期安排。


阶段三适合公司业务基本成熟，业务线较多，开发资源充足。切记不要过早的拆分微服务，会白白增加开发成本，得不偿失。如果公司规模尚小，开发人员较少，过早的将服务拆分。会造成一个开发不得不同时维护多个微服务项目。为了完成一个需求，一个开发不得不同时修改多个项目。



# 不要过早的拆分数据层

为什么说不要过早的拆分数据层，如果微服务拆分的够细，每个微服务都有自己的数据层，并且数据库尚未分库，多个微服务公用一个数据库。那么将面临一个不得不提及的问题。分布式事务。

举个例子：如果对于现在用户要完成一个任务，需要同时调用service1(记为s1)，service2， service3，并且需要原子性。即这三个请求要么同时成功，要么同时失败。比如s1 减库存， s2是锁定优惠券， s3是创建订单。这三个服务不同的开发者，部署在不同服务器。

对于这三个子服务来讲，各自可以用维持自己的事务很容易，但是如何保证三个服务一起来保证事务呢。

## 不涉及分布式事务

1. 首先考虑公司是否发展到这种地步，是否要将颗粒度拆分到如此程度。如果没有必要，对于这种业务紧密的服务可以不进行拆分，将这三个服务放在同一个大服务中。
2. 另外一中是，将数据层放在统一服务中，最终访问数据库时，在一个服务中，不涉及分布式事务。
3. 仍然是考虑不产生分布式事务，将数据库也按照业务来分库，将强事务关联的表放在同一个数据库中。这样拆分数据层也没关系，对于每个服务来讲，仍然自己独占一个数据库。

以上几种只是为暂时解燃眉之急来用，随着业务规模的扩大，分布式事务的问题迟早要解决。

## 技术层面 直面分布式事务

比较经典的方案就是两段提交(Two-phase Commit)。这种方法大体意思就是有个协调者和分阶段

阶段1，协调者跟所有参与者是否准备好了
参与者开始做一些准备工作，记录undo/redo log等
阶段2，如果所有的参与者都回应准备好了，那么，协调者向所有的参与者发送“正式提交”的命令。参与者完成正式提交，并释放所有资源，然后回应“完成”，协调者收集各结点的“完成”回应后结束这个Global Transaction。如果有一个参与者回应“拒绝提交”，那么，协调者向所有的参与者发送“回滚操作”，并释放所有资源，然后回应“回滚完成”，协调者收集各结点的“回滚”回应后，取消这个Global Transaction。
